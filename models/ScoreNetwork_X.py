import torch
import torch.nn.functional as F

from models.layers import DenseGCNConv, MLP
from utils.graph_utils import mask_x


class ScoreNetworkX(torch.nn.Module):

    def __init__(self, max_feat_num, depth, nhid, condition_dim):

        super(ScoreNetworkX, self).__init__()

        self.nfeat = max_feat_num 
        self.depth = depth  
        self.nhid = nhid  

        self.condition_linear = torch.nn.Linear(condition_dim, max_feat_num)  

        self.layers = torch.nn.ModuleList()

        for _ in range(self.depth):
            if _ == 0:
                self.layers.append(DenseGCNConv(self.nfeat, self.nhid))
            else:
                self.layers.append(DenseGCNConv(self.nhid, self.nhid))

        self.fdim = self.nfeat + self.depth * self.nhid
        self.final = MLP(num_layers=3, input_dim=self.fdim, hidden_dim=2 * self.fdim, output_dim=self.nfeat,
                         use_bn=False, activate_func=F.elu)
        self.activation = torch.tanh

    def forward(self, x, adj, flags, condition):

        con_feat = self.condition_linear(condition)

        x = x + con_feat.unsqueeze(1)

        x_list = [x]
        for _ in range(self.depth):
            x = self.layers[_](x, adj)
            x = self.activation(x)
            x_list.append(x)

        xs = torch.cat(x_list, dim=-1)  # B x N x (F + num_layers x H)
        out_shape = (adj.shape[0], adj.shape[1], -1)
        
        x = self.final(xs).view(*out_shape)
        x = mask_x(x, flags)

        return x



